/*!
    Copyright 2023 ООО "НПФ ВЕКТОР"

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 
 \file      V_adc.c
 \brief     Модуль обработки АЦП (см. TAdcDrv)
 \author    ООО "НПФ Вектор". http://motorcontrol.ru
 \version   v 2.0 25/03/2016

 \addtogroup V_adc 
 @{*/

#include "DSP.h"
#include "V_adc.h"
#include "main.h"
#include "string.h" //длЯ memset

//!Инициализация.

#define CPU_CLOCK_SPEED      6.6667L   // for a 150MHz CPU clock speed
#define ADC_DELAY 5000.0L
#define DELAY_US(A)  DSP28x_usDelay(((((long double) A * 1000.0L) / (long double)CPU_CLOCK_SPEED) - 9.0L) / 5.0L)

extern TAdcDrv adc;
extern TDrvParams drv_params;

//! \memberof TAdcDrv
void AdcDrv_init(TAdcCalibration *p) {

    int i;

    //----------------------------------------------------------------------
    // To powerup the ADC the ADCENCLK bit should be set first to enable
    // clocks, followed by powering up the bandgap and reference circuitry.
    // After a 5ms delay the rest of the ADC can be powered up. After ADC
    // powerup, another 20us delay is required before performing the first
    // ADC conversion.
    //
    // V1.1: Fixed bug. Was disabling clock but disabling was not working
    //       because EALLOW and EDIS did not ave a space and hence were
    //       treated as labels. ADC clock was enabled in a previous function
    //       so thats why V1.0 program worked anyway.
    //если версиЯ процессора больше D то опорные уровни внешние
    //if (sm_sys.SiliconRevision>3)
#warning проверить настройку опорных уровней
    AdcRegs.ADCTRL3.all=0x0100;
    //AdcRegs.ADCTRL3.all=0x0000;
    DELAY_US(ADC_DELAY);

    asm(" EALLOW");
    SysCtrlRegs.PCLKCR.bit.ADCENCLK = 1;      // Power up clocks to ADC
    asm(" EDIS");

    AdcRegs.ADCTRL3.bit.ADCBGRFDN = 0x3;    // Power up bandgap/reference circuitry
    DELAY_US(ADC_DELAY);
    // Delay before powering up rest of ADC
    AdcRegs.ADCTRL3.bit.ADCPWDN = 1;        // Power up rest of ADC
    DELAY_US(ADC_DELAY);
    // Delay after powering up ADC
    AdcRegs.ADCTRL3.bit.ADCCLKPS = 3;           // ADCCLK=25Mhz
    AdcRegs.ADCTRL1.bit.ACQ_PS = 0;             // Acq Time=3ADC CLK

#if ADC_SAMPLING_MODE == SIMULTANEOUS
    AdcRegs.ADCTRL3.bit.SMODE_SEL = 1;
    AdcRegs.ADCMAXCONV.all = 7;
#endif

#if ADC_SAMPLING_MODE == SEQUENTIAL
    AdcRegs.ADCTRL3.bit.SMODE_SEL = 0;
    AdcRegs.ADCMAXCONV.all = 15;
#endif

    AdcRegs.ADCCHSELSEQ1.all = 0x3210;
    AdcRegs.ADCCHSELSEQ2.all = 0x7654;
    AdcRegs.ADCCHSELSEQ3.all = 0xba98;
    AdcRegs.ADCCHSELSEQ4.all = 0xfedc;
    AdcRegs.ADCTRL1.bit.SEQ_CASC = 0x1;
    //----------------------------------------------------------------------
    // ADC is configured to start a conversion from the SOC signal
    // generated by EV-A:
    //
    AdcRegs.ADCTRL2.bit.EVA_SOC_SEQ1 = 1;  // Enable EVASOC to start SEQ1
    AdcRegs.ADCTRL2.bit.INT_ENA_SEQ1 = 1;  // Enable SEQ1 interrupt (every EOS)

    p->init(p); //Инициализируем калибровщик АЦП

    //----------------------------------------------------------------------
    // Start ADC:
    //
    AdcRegs.ADCTRL2.bit.SOC_SEQ1 = 1;

    //----------------------------------------------------------------------
    // Wait for ADC to finish conversions (test INT1 flag):
    //
    while (AdcRegs.ADCST.bit.INT_SEQ1 == 0) {
    }
    AdcRegs.ADCST.bit.INT_SEQ1_CLR = 1;
    for (i = 0; i < 100; i++)   //TODO: непонятно, нужна ли эта задержка тут. Вместо ; раньше вообще было 100 раз присваивание высокого опорного канала калибровщика АЦП.
        ;

}


//!Расчет АЦП с частотой основного расчета всей системы управления (обычно 10кГц).

//! Занимается обработкой измеренных АЦП значений и преобразует в формат IQ24.
//! Токи фаз для повышения точности усредняются за несколько измерений
//!
//! Сдвиг на 4 вверх для данных из АЦП делается для приведения 12ти разрядного результата АЦП к 16ти разрядному виду, чтобы
//! получившееся число трактовалось как знаковое, а операция ^ 0x8000, если рассмотреть её побитово,
//! сдвигает число на половину диапазона и делает его знаковым. Т.е. в результате этих двух операций значения АЦП от 0 до 4096
//! преобразуются в диапазон от -32768 до +32767, а половина диапазона АЦП (2048, ноль показаний датчиков тока)
//! оответствует 0 в преобразованном формате. Такой битовый хак сделан для ускорения вычислений. Его можно заменить на
//! вычитание из результата АЦП 2048 и умножение на соответствущее число для получения аналогичного результата.

//! \memberof TAdcDrv

#if defined(HW_MOTORCONTROLBOARD)
void AdcDrv_fast_calc(TAdcDrv *p) {

    p->IA_temp = AdcRegs.ADCRESULT0;
    p->IC_temp = AdcRegs.ADCRESULT1;
	p->Udc_temp = AdcRegs.ADCRESULT2;

	p->ref_temp = AdcRegs.ADCRESULT3;

	p->T_temp = AdcRegs.ADCRESULT9;


	p->Imeas_a = p->IaGainNom * ((p->IA_temp + p->Imeas_a_offset));
	p->Imeas_c = p->IcGainNom * ((p->IC_temp + p->Imeas_c_offset));
	p->Udc_meas = p->UdcGainNom * (p->Udc_temp + p->Udc_meas_offset);

	p->Imeas_b = -p->Imeas_a - p->Imeas_c;
	p->T_meas = p->TGainNom * (p->T_temp);		//датчик температуры без смещения
	p->ref_meas = p->refGainNom * ((p->ref_temp + p->ref_meas_offset));

}
#endif


//!Медленный расчет.

//!Занимается пересчетом коэффициентов, используемых в скоростной функции расчета,
//!чтобы не занимать процессорное время там. Находит коэффициенты,
//!на которые надо умножить полученное с АЦП значение, чтобы получить
//!относительные единицы с заданной базой.

//! Пример   p->PvalveGainNom=_IQ16mpy(p->Pvalve_gain,_IQ(1.0/100));
//! Pvalve_gain - значение в формате int. задается пользователем в UniCON.
//!Определяет, скольким процентам соответствует полный диапазон АЦП. В простейшем случае
//!равен 100. Т.е. когда на АЦП максимальный сигнал, это соответствует 100%.

//!_IQ(1.0/100) обратное значение для масштабирующего коэффициента. Так как величину процентов
//!естественнее всего перевести в относительные единицы так, что 100% соответствут 1.0,
//!то масштабирующий коэффициент (база) равен 100. Т.е. UniCON, прочитав из системы управления
//! число 1.0 в формате 8.24 должен умножить его на 100, чтобы отобразились проценты.
//! Здесь коэффициент задан явно как 1.0/100, но для ряда случаев базовое значение нужно менять.
//!Так, для токов фаз используется значение _1_I_nom, в формате 8.24, соответствующее единице деленной на
//базовое значение тока, например, 200 А. Так как в зависимости от мощности преобразователя базовый ток может меняться,
//то это значение, в отличие от процентов, сделано настраиваемым. Расчет _1_I_nom идет в другом месте, так как
//занимает много тактов расчета.

//Для беззнакового значения АЦП измеряет число от 0 до 4096.
//Для примера с процентами необходимо сделать так, чтобы получилось результирующее значение в формате 8.24,
//где 1.0 это 4096. Таким образом, нужно сдвинуть число 4096 на 4 разряда.

//Таким образом, PvalveGainNom - это коэффициент в формате 24.8. он получается в результате использования функции
//_IQ16mpy, аргумены которой Pvalve_gain (int) и 1.0/100 в формате 8.24. Функция IQ множения
//по сути представляет собой обычное оуможение в 64 разрядах со сдвигом результата вправо на Q разрядов.
//Т.е. _IQ16mpy умножает число в формате IQ24 9второй аргумент) на целочисленный коэффициент (первый аргумент),
//а потом сдвигате результат на 16 разрядов вправо.
//Так, в результате _IQ16mpy(p->Pvalve_gain,_IQ(1.0/100)); получается целочисленное число 255, являющейся
//1.0 в формате 24.8 из-за сдвига на 16 разрядов вправо.

//Всё вышеприведенное мутево сделано с одной целью - увеличить производитльность обработки АЦП.

//! \memberof TAdcDrv
void AdcDrv_slow_calc(TAdcDrv *p) {
	p->IaGainNom = _IQ16mpy(p->Imeas_a_gain, drv_params._1_I_nom) << 1;
	p->IbGainNom = _IQ16mpy(p->Imeas_b_gain, drv_params._1_I_nom) << 1;
	p->IcGainNom = _IQ16mpy(p->Imeas_c_gain, drv_params._1_I_nom) << 1;
	p->IdGainNom = _IQ16mpy(p->Imeas_d_gain, drv_params._1_I_nom) << 1;
	p->UdcGainNom = _IQ16mpy(p->Udc_meas_gain, drv_params._1_Udc_nom) << 4;
	p->TGainNom = _IQ16mpy(p->T_meas_gain, _IQ(0.05)) << 4;	//0.05 = 1/20, где 20 градусов по Цельсию - номинальная (базовая) температура
	p->refGainNom = _IQ16mpy(p->ref_meas_gain, _IQ(1.0/100)) << 4;
}

//! Миллисекундный расчет

//! \memberof TAdcDrv
void AdcDrv_ms_calc(TAdcDrv *p) {

}

/*@}*/

